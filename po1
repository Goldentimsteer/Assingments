 
  __    __   ______     __                                           
 |  \  |  \ /      \  _/  \                                          
 | $$  | $$|  $$$$$$\|   $$                                          
 | $$__| $$| $$$\| $$ \$$$$                                          
 | $$    $$| $$$$\ $$  | $$                                          
 | $$$$$$$$| $$\$$\$$  | $$                                          
 | $$  | $$| $$_\$$$$ _| $$_                                         
 | $$  | $$ \$$  \$$$|   $$ \                                        
  \$$   \$$  \$$$$$$  \$$$$$$                                        
                                                                     
                                                                     
                                                                     
   ______     __  __    __   ______                                  
  /      \  _/  \|  \  |  \ /      \                                 
 |  $$$$$$\|   $$| $$  | $$|  $$$$$$\                                
  \$$__| $$ \$$$$| $$__| $$ \$$__| $$                                
  /      $$  | $$| $$    $$  |     $$                                
 |  $$$$$$   | $$ \$$$$$$$$ __\$$$$$\                                
 | $$_____  _| $$_     | $$|  \__| $$                                
 | $$     \|   $$ \    | $$ \$$    $$                                
  \$$$$$$$$ \$$$$$$     \$$  \$$$$$$                                 
                                                                     
                                                                     
                                                                     
   ______   _______   ______  ________  ________  ________  __    __ 
  /      \ |       \ |      \|        \|        \|        \|  \  |  \
 |  $$$$$$\| $$$$$$$\ \$$$$$$| $$$$$$$$| $$$$$$$$| $$$$$$$$| $$\ | $$
 | $$ __\$$| $$__| $$  | $$  | $$__    | $$__    | $$__    | $$$\| $$
 | $$|    \| $$    $$  | $$  | $$  \   | $$  \   | $$  \   | $$$$\ $$
 | $$ \$$$$| $$$$$$$\  | $$  | $$$$$   | $$$$$   | $$$$$   | $$\$$ $$
 | $$__| $$| $$  | $$ _| $$_ | $$      | $$      | $$_____ | $$ \$$$$
  \$$    $$| $$  | $$|   $$ \| $$      | $$      | $$     \| $$  \$$$
   \$$$$$$  \$$   \$$ \$$$$$$ \$$       \$$       \$$$$$$$$ \$$   \$$
                                                                     
                                                                     
                                                                     
 

///////////////////////////////////////////////////////////////////////////////
//                   
// Author:           Timothy Lockhart
// Email:            tlockhartjr@icloud.com
// Label:            L02
// Title:            Array Based Stack Example
// Course:           2143
// Semester:         Fall 2020
//
// Description:
//       Example implementation of an array based stack that holds integers.
//
// Usage:
//       Nothing special right now.
//
// Files:            
//       None
/////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <string>
using namespace std;

/**
 * Stack
 *
 * Description:
 *      Integer array based stack implementation
 *
 * Public Methods:
 *      - Stack()
 *      - Stack(int)
 *      - void Push()
 *      - int Pop()
 *      - bool empty()
 *      - bool full()
 *      - void Print()
 *
 * Private Methods:
 *      - None
 *
 * Usage:
 *
 *  Stack S;
 *  S.Push(80);
 *  S.Push(90);
 *  S.Print();
 *  int x = S.Pop();
 *
 */
class Stack {
private:
    int* S;       //array pointer
    int* A;       //array pointer
    int capacity; //max stack size
    int top;      //current top (index)
    int size;     //current num items
    int Asize;    //how many numbers are in the array
public:
    /**
     * Stack:
     *    Constructor.
     * Params:
     *    void
     *
     * Returns:
     *     Void
     */
    Stack() {
        capacity = 10;          // set array size
        S = new int[capacity];  // allocate new memory
        top = -1;               // initialize top of stack
        size = 0;               // set stack to empty
        Asize = 0;              // set the size to zero
    }

    /**
     * Stack:
     *    Constructor.
     * Params:
     *    int : capacity
     *
     * Returns:
     *     Void
     */
    Stack(int cap) {
        capacity = cap;         // set array size      
        S = new int[capacity];  // allocate new memory
        top = -1;               // initialize top of stack
        size = 0;               // set stack to empty
        Asize = 0;              // set size to zero
    }

    /**
     * Push:
     *    Push item onto stack.
     * Params:
     *    int : data
     *
     * Returns:
     *     Void
     */
    void Push(int data) {
        top++;              // move top of stack up
        size++;             // increment size
        Full();
        S[top] = data;      // add item to array
        Asize++;
        
       
    }

    /**
     * Pop:
     *    remove item from stack.
     * Params:
     *    void
     *
     * Returns:
     *     void
     */
    void Pop() {
        Asize--;
        Empty();
        
        top--;              // shrink the stack
        size--;             // update our size
        
        
        
    }

    /**
     * Empty:
     *    is the stack empty?
     * Params:
     *    void
     *
     * Returns:
     *     int
     */
    int Empty() {
        if (Asize == 0)
        {
           
            return 0;
            cout << "the stack is empty" << endl;
        }
        
        else
        { 
            cout << "poped a ";
            int data = S[top];  // pull item from stack  
            cout << data << endl;
            return data;
            
        }
    }

    /**
     * Full:
     *    is the stack full?
     * Params:
     *    void
     *
     * Returns:
     *     void
     */
    void Full() {
        if (Asize == capacity)
        {
            
            cout << "overflow " << endl;
            A = new int[2 * capacity];  // allocate more memory 
            for (int i = 0; i < capacity; i++)
            {
                A[i]=S[i];
            }
    
        } 
    }

    /**
     * Print:
     *    Used so we can inspect our stack.
     * Params:
     *    void
     *
     * Returns:
     *     void
     */
    void Print() {
        for (int i = top; i >= 0; i--) {
            cout << S[i] << endl;
        }
       
        
    }

    /**
     * Overloaded ostream <<
     *    Lets us print a stack using cout
     * Params:
     *    ostream &os   : instance of ostream passed in by reference
     *    const Stack   : instance of stack passed in using const so
     *                    it cannot be changed
     *
     * Returns:
     *     ostream
     */
    friend ostream& operator<<(ostream& os, const Stack s) {
        for (int i = s.top; i >= 0; i--) {
            os << s.S[i] << endl;
        }
        return os;
    }
};







int main() {
    Stack S1;           // calls default constructor
    //Stack S2(25);       // calls overloaded constructor
    
    
    S1.Push(1);
    S1.Push(2);
    S1.Push(3);
    S1.Push(4);
    S1.Push(5);
    S1.Push(6);
    S1.Push(7);
    S1.Push(8);
    S1.Push(9);
    S1.Push(10);
    S1.Push(11);
    S1.Push(12);
    S1.Push(13);

    S1.Print();
    
   
  
    //S1.Pop();
    //S1.Pop();
  
    

    


}
